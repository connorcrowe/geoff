# Query Builder

## Purpose
To take in a structured, consistent JSON plan generated by the LLM and turn it into one or more SQL statements representing map layers.

## Input/Output Contract

### Input
A JSON plan (Python dict), structure defined in [`json_plan.md`](./json_plan.md).

### Output
A list of layer objects, where each layer contains:
- `sql`: Valid PostGIS SQL statement
- `layer_name`: Suggested display name for the layer
- `layer_type`: Classification (e.g., "primary", "context", "reference")

### Assumptions
- Input JSON is pre-validated and well-formed
- All table and column references exist in the database schema
- Geometry columns must always be included in SELECT as `ST_AsGeoJSON(geometry) AS geometry`

## Query Components

### Simple Select
- Selecting from a table to return results
    - "Show all attractions"
        - ```["""SELECT attractions.name, attractions.category, attractions.address, attractions.description, ST_AsGeoJSON(attractions.geometry) AS geometry FROM attractions;"""]```
- Selecting from several, unrelated tables
    - "Show parks and schools"
        - ```["""SELECT schools.name, schools.school_type_desc, ST_AsGeoJSON(schools.geometry) AS geometry FROM schools;""", """SELECT parks.name, parks.type, ST_AsGeoJSON(parks.geometry) AS geometry FROM parks;"""]```

### WHERE and Filters
- Supported operations: `<`, `<=`, `>`, `>=`, `=`, `!=`, `ILIKE`, `NOT ILIKE`, `BETWEEN`, `NOT BETWEEN`, `IN`, `NOT IN`, `IS NULL`, `IS NOT NULL`
- Supported logical operators: `AND`, `OR`
- Simple example:
    - "Get all fire stations built before 1980"
        - ```["""SELECT fire_stations.station_no, fire_stations.address, fire_stations.year_built, ST_AsGeoJSON(fire_stations.geometry) AS geometry FROM fire_stations WHERE year_built < 1980;"""]```
- Logical example:
    - "Show protected bike lanes installed since 2020"
        - ```[""" ... WHERE (lane_type ILIKE '%protected%' AND installed_year >= 2020 ) ... """] ```

### Spatial Filter
- Supported operations: `ST_DWithin`, `ST_Intersects`, `ST_Contains`, `ST_Within`
- Filter by spatial feature (also show context layer):
    - "Show bike lanes within 500m of schools"
        - ```["""SELECT DISTINCT bike_lanes.street_name, bike_lanes.lane_type, ST_AsGeoJSON(bike_lanes.geometry) AS geometry FROM bike_lanes WHERE EXISTS (SELECT 1 FROM schools WHERE ST_DWITHIN(bike_lanes.geometry::geography, schools.geometry::geography, 500));""", """SELECT DISTINCT schools.name, schools.school_type_desc, ST_AsGeoJSON(schools.geometry) AS geometry FROM schools;"""] ```

### Spatial Join
- Supported operations: `ST_DWithin`, `ST_Intersects`, `ST_Contains`, `ST_Within`
- Example:
    - "List each school and the nearest fire station within 1 kilometer"
        - ``` ["""SELECT DISTINCT schools.name, ST_AsGeoJSON(schools.geometry) AS geometry, fire_stations.station_no, fire_stations.address, fire_stations.municipality FROM schools JOIN fire_stations ON ST_DWITHIN( schools.geometry::geography, fire_stations.geometry::geography, 1000);"""]```

### Attribute Filter
- Filtered based on non-spatial property:
    - "Show the ward that the Allan Gardens are in"
        - ```["""SELECT DISTINCT wards.name, wards.ward_id, ST_AsGeoJSON(wards.geometry) AS geometry FROM wards WHERE EXISTS ( SELECT 1 FROM attractions WHERE name ILIKE '%Allan Gardens%' AND (wards.ward_id = attractions.ward_id));""", """SELECT DISTINCT attractions.name, attractions.ward_id, ST_AsGeoJSON(attractions.geometry) AS geometry FROM attractions WHERE name ILIKE '%Allan Gardens%';"""]```

### Attribute Join
- Joined based on non-spatial property:
    - "Join attractions with wards by matching ward_id"
        - ```["""SELECT DISTINCT attractions.name, attractions.ward_id, ST_AsGeoJSON(attractions.geometry) AS geometry, wards.ward_id, wards.name FROM attractions JOIN wards ON (attractions.ward_id = wards.ward_id);"""]```

### Aggregations and Groups
- Grouping based on aggregation
- Examples:
    - "Total parking lot area within each neighbourhood?"
        - ```["""SELECT n.id AS neighbourhood_id, n.area_name, SUM(ST_Area(pl.geometry::geography)) AS total_parking_area_m2, ST_AsGeoJson(n.geometry) as geometry FROM neighbourhoods n JOIN parking_lots pl ON ST_Intersects(n.geometry, pl.geometry) GROUP BY n.id, n.area_name, n.geometry;"""]```
    - "How many meters of bike lane are within 500 m of any school, by lane type?"
        - ```["""SELECT bl.lane_type, SUM(ST_Length(bl.geometry::geography)) AS total_length FROM bike_lanes bl WHERE EXISTS ( SELECT 1 FROM schools s WHERE ST_DWithin(bl.geometry, s.geometry, 500)) GROUP BY bl.lane_type;"""]```

### ORDER BY and LIMIT
- Example:
    - "Show the 5 longest bike lanes"
        - ```["""SELECT bike_lanes.street_name, bike_lanes.from_street, bike_lanes.to_street, to_char(st_length(geometry::geography), 'FM999,999,999,999,999.99') as bike_lanes_length_m, ST_AsGeoJSON(bike_lanes.geometry) AS geometry FROM bike_lanes ORDER BY st_length(geometry::geography) DESC LIMIT 5;"""]```
    
### Subqueries and CTE
- Support subqueries and CTEs for readability
- Example:
    - "Show neighbourhoods with more than 10 parks"
        - ```["""WITH park_counts AS (SELECT n.area_name, n.geometry, COUNT(*) AS park_count FROM parks p INNER JOIN neighbourhoods n ON ST_Intersects(p.geometry, n.geometry) GROUP BY n.area_name, n.geometry) SELECT pc.area_name, pc.park_count, ST_AsGeoJSON(pc.geometry) AS geometry FROM park_counts pc WHERE pc.park_count > 10;"""]```

### UNION
- Support union to merge tables
- Example:
    - "Merge all emergency service locations (fire, police, ambulance) into one layer"
        - ```["""SELECT fs.address AS location, 'Fire Station' AS service_type, CAST(fs.station_no AS text) AS identifier, ST_AsGeoJSON(fs.geometry) AS geometry FROM fire_stations fs UNION ALL SELECT ps.address AS location, 'Police Station' AS service_type, ps.name AS identifier, ST_AsGeoJSON(ps.geometry) AS geometry FROM police_stations ps UNION ALL SELECT ems.address AS location, 'Ambulance Station' AS service_type, ems.ems_name AS identifier, ST_AsGeoJSON(ems.geometry) AS geometry FROM ambulance_stations ems;"""]```

## Column Types

### Spatial Columns
- Supported operations: `ST_Length`, `ST_Area`, `ST_Centroid`, `ST_Perimeter`
- Example:
    - "Show bike lanes longer than 500 meters"
        - ```["""SELECT bike_lanes.street_name, bike_lanes.from_street, bike_lanes.to_street, to_char(st_length(geometry::geography), 'FM999,999,999,999,999.99') as bike_lanes_length_m, ST_AsGeoJSON(bike_lanes.geometry) AS geometry FROM bike_lanes WHERE st_length(bike_lanes.geometry::geography) > 500;"""]```

### Computed Columns
- Aggregates, expressions, and combinations
- May require formatting with `to_char()`
- Example:
    - "Show what percentage of each neighbourhood is parking lot"
        - ```["""... (SUM(ST_Area(pl.geometry::geography)) / ST_Area(n.geometry::geography) * 100) AS parking_as_pct_of_area, ..."""]```

### Aggregate Columns
- Supported operations: `SUM`, `COUNT`, `AVG`, `MIN`, `MAX`, `STDDEV`
- Example:
    - "How many schools are within 500m of a park?"
        - ```["""SELECT COUNT(*) AS num_schools FROM schools s WHERE EXISTS (SELECT 1 FROM parks p WHERE ST_DWithin(s.geometry, p.geometry, 500));"""]```

## Context Layer Generation

### Philosophy
Users perform spatial analysis and need visual context. The query builder automatically generates additional layers to provide spatial reference for filtering/joining operations.

### Automatic Context Layer Rules
1. **Spatial Filter Context**: When a spatial filter is applied (e.g., "within 500m of X"), generate a separate layer showing the filtering geometry (X)
2. **Join Context**: When joining tables spatially, both geometries should be returned as separate layers if meaningful for analysis
3. **Aggregation Context**: When aggregating data into a parent geometry, show both the aggregate result AND the source features
4. **Multiple Tables**: When querying unrelated tables, return each as its own layer

### Layer Classification
- **primary**: Main result answering the user's question
- **context**: Spatial reference for filters/joins  
- **reference**: Supporting data for aggregations

### Context Layer Examples

| User Query | Primary Layer | Context Layers |
|------------|---------------|----------------|
| "Show parks and schools" | parks | schools |
| "Bike lanes within 500m of schools" | filtered bike_lanes | schools |
| "Total parking area per neighbourhood" | neighbourhoods (with parking_area) | parking_lots |

## Implementation Details

### Aliasing
- **Tables**: Use aliases when needed for joins or self-joins (e.g., `n` for neighbourhoods, `pl` for parking_lots)
- **Columns**: Alias computed columns with descriptive names (e.g., `total_parking_area_m2`, `bike_lanes_length_m`)
- **Layers**: Generate from primary table name (e.g., `bike_lanes`, `schools_filtered`)
- **CTEs**: Use descriptive aliases (e.g., `park_counts`, `filtered_lanes`)

### Geometry Handling
- **MUST** cast to `::geography` for distance-based operations (`ST_DWithin`, `ST_Length`, `ST_Area`)
- **MUST** output as `ST_AsGeoJSON(geometry) AS geometry` in SELECT
- Keep original `geometry` column for spatial operations within the query
- Use appropriate spatial operations based on geometry types (point/line/polygon)

### Query Optimization
- Use `EXISTS` subqueries for spatial filters (more efficient than JOINs for filtering)
- Use `DISTINCT` when joins might create duplicates
- Use `UNION ALL` instead of `UNION` when duplicates are not a concern
- Consider that spatial operations benefit from GIST indexes on geometry columns
- For large datasets, consider adding appropriate WHERE clauses early in the query